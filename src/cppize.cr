require "./cppize/*"
require "./cppize/nodes/*"
# require "compiler/crystal/program"
# require "compiler/crystal/semantic/**"
# require "compiler/crystal/macros"
# require "compiler/crystal/macros/**"
# require "compiler/crystal/syntax/**"
# require "compiler/crystal/tools/**"
# require "compiler/crystal/semantic/ast"
# require "compiler/crystal/semantic/type_lookup"
# require "compiler/crystal/semantic/class_vars_initializer_visitor"
# require "compiler/crystal/semantic/method_lookup"
# require "compiler/crystal/codegen/link"
# require "compiler/crystal/codegen/target_machine"
# require "compiler/crystal/crystal_path"
require "compiler/crystal/**"
# require "cppize/inference/*"
require "llvm/**" # For compiler/crystal/semantic/***

class Crystal::Program
  @crystal_path : CrystalPath?
end

module Cppize
  include Crystal

  class Transpiler
    property options

    @options = Hash(String, String?).new

    alias Scope = Hash(String, NamedTuple(symbol_type: Symbol, value: ASTNode?))

    @scopes = Array(Scope).new

    def find_var(name : String) : NamedTuple(symbol_type: Symbol, value: ASTNode?)
      if name == "self"
        return {symbol_type: :pointer, value: nil}
      end
      @scopes.each do |h|
        if h.has_key? name
          return h[name]
        end
      end
      {symbol_type: :undefined, value: nil}
    end

    property? failsafe : Bool
    property? use_preprocessor_defs : Bool
    @use_preprocessor_defs = false

    def initialize(@failsafe = false)
    end

    CORE_TYPES = [
      "Int", "Int8", "Int16", "Int32", "Int64",
      "UInt", "UInt8", "UInt16", "UInt32", "UInt64",
      "Char", "String", "Array", "StaticArray", "Pointer",
      "Size", "Object", "Hash",
    ]

    BUILTIN_TYPES = [
      "Void", "Auto", "NativeInt",
    ]

    COMMENT = %(
/*
  Autogenerated with Cppize
  Cppize is an open-source Crystal-to-C++ transpiler
*/
    )

    def initial_defines
      lines = [] of String
      lines << "#define CPPIZE_NO_RTTI" if options.has_key? "no-rtti"
      lines << "#define CPPIZE_USE_PRIMITIVE_TYPES" if options.has_key? "primitive-types"
      lines << "#define CPPIZE_NO_EXCEPTIONS" if options.has_key? "no-exceptions"
      lines << "#define CPPIZE_NO_STD_STRING" if options.has_key? "no-std-string"
      lines << "#define CPPIZE_NEW_AS_METHOD" if options.has_key? "new-as-method"
      lines << "#include <crystal/stdlib.hpp>" unless options.has_key? "no-stdlib"
      lines.join("\n")
    end

    def parse_and_transpile(code : String)
      initial_defines + "\n" + COMMENT + "\n" + transpile Parser.parse(code)
    end

    def parse_and_transpile(file : IO)
      parse_and_transpile file.gets_to_end
    end

    def parse_and_transpile_file(file : String)
      parse_and_transpile File.read file
    end

    class Error < ArgumentError
      property? catched : Bool
      @catched = false
    end

    def pretty_signature(d : Def) : String
      restrictions = d.args.map &.restriction
      unless d.args.all? { |x| x.restriction }
        raise ArgumentError.new "No type restrictions on #{d.args.select { |x| !x.restriction }.join(",")} (method #{d.name})"
      end
      "#{d.name}(#{restrictions.map(&.to_s).join(",")})" + (d.return_type ? " : #{d.return_type.to_s}" : "")
    end

    def transpile(node, should_return : Bool = false)
      if @failsafe
        "#warning Node type #{node.class} isn't supported yet"
      else
        raise Error.new("Node type #{node.class} isn't supported yet")
      end
    end

    def transpile_type(_n : String)
      if _n.match(/\|/)
        raise Error.new("Union types are not supported yet (type #{_n})")
      elsif CORE_TYPES.includes?(_n)
        "crystal::#{_n.downcase}"
      elsif BUILTIN_TYPES.includes?(_n)
        _n.downcase
      else
        _n
      end
    end

    def transpile(node : TypeNode, should_return : Bool = false)
      (should_return ? "return " : "") + transpile_type(node.to_s)
    end

    def transpile(node : Path, should_return : Bool = false)
      node.names[0] = transpile_type node.names.first
      (should_return ? "return " : "") + (node.global? ? "::" : "") + "#{node.names.join("::")}"
    end

    def transpile(node : Generic, should_return : Bool = false)
      (should_return ? "return " : "") + "#{transpile node.name}< #{node.type_vars.map { |x| transpile x }.join(",")} >"
    end

    def transpile(node : Nop, should_return : Bool = false)
      ""
    end
  end
end
