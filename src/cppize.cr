require "./cppize/*"
require "./cppize/nodes/*"
# require "compiler/crystal/program"
# require "compiler/crystal/semantic/**"
# require "compiler/crystal/macros"
# require "compiler/crystal/macros/**"
# require "compiler/crystal/syntax/**"
# require "compiler/crystal/tools/**"
# require "compiler/crystal/semantic/ast"
# require "compiler/crystal/semantic/type_lookup"
# require "compiler/crystal/semantic/class_vars_initializer_visitor"
# require "compiler/crystal/semantic/method_lookup"
# require "compiler/crystal/codegen/link"
# require "compiler/crystal/codegen/target_machine"
# require "compiler/crystal/crystal_path"
require "compiler/crystal/**"
require "llvm/**" # For compiler/crystal/semantic/***

# W/ Love; From Neo.
#................00000000000
#..............00,,,,,,,0,,,,,,00 
#.............0,,,,,,,,,0,,,,,,,,,0 
#............0,,,,,,,,,,0,,,,,,,,,,0 
#...........0,,,,,,,,,,,0,,,,,,,,,,,0 
#...........0,,,,,,,,,,,,,,,,,,,,,,,,0 
#...........0,,,,,,,,,,,,,,,,,,,,,,,,0 
#...........0,,,,,,,,,,,,,,,,,,,,,,,,0 
#............0,,,,,,,,,,,,,,,,,,,,,0 
#.............000000000000000 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.............0,,,,,,,,,,,,,,,,,,,0 
#.........000,,,,,,,,,,,,,,,,,,,,,,000 
#.......00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,00 
#......0,,,,,,,,,,,,,,,,,0,,,,,,,,,,,,,,,,0 
#.....0,,,,,,,,,,,,,,,,,,,0,,,,,,,,,,,,,,,,0 
#....0,,,,,,,,,,,,,,,,,,,,,0,,,,,,,,,,,,,,,,0 
#...0,,,,,,,,,,,,,,,,,,,,,,0,,,,,,,,,,,,,,,,0 
#...0,,,,,,,,,,,,,,,,,,,,,,0,,,,,,,,,,,,,,,,0 
#...0,,,,,,,,,,,,,,,,,,,,,0,,,,,,,,,,,,,,,,0 
#....0,,,,,,,,,,,,,,,,,,,0,,,,,,,,,,,,,,,,0 
#.....0,,,,,,,,,,,,,,,,,0,,,,,,,,,,,,,,,0


class Crystal::Program
  @crystal_path : CrystalPath?
end

module Cppize
  include Crystal

  class Transpiler
    alias Scope = Hash(String, NamedTuple(symbol_type: Symbol, value: ASTNode?))

    @scopes = Array(Scope).new

    def find_var(name : String) : NamedTuple(symbol_type: Symbol, value: ASTNode?)
      @scopes.each do |h|
        if h.has_key? name
          return h[name]
        end
      end
      {symbol_type: :undefined, value: nil}
    end

    property? failsafe : Bool
    property? use_preprocessor_defs : Bool
    @use_preprocessor_defs = false

    def initialize(@failsafe = false)
    end

    CORE_TYPES = [
      "Int", "Int8", "Int16", "Int32", "Int64",
      "UInt", "UInt8", "UInt16", "UInt32", "UInt64",
      "Char", "String", "Array", "StaticArray", "Pointer",
    ]

    BUILTIN_TYPES = [
      "Void", "Auto", "NativeInt",
    ]

    COMMENT = %(
/*
  Autogenerated with Cppize
  Cppize is an open-source Crystal-to-C++ transpiler
*/
    )

    def parse_and_transpile(code : String)
      COMMENT + "\n" + transpile Parser.parse(code)
    end

    def parse_and_transpile(file : IO)
      parse_and_transpile file.gets_to_end
    end

    def parse_and_transpile_file(file : String)
      parse_and_transpile File.read file
    end

    class Error < ArgumentError
      property? catched : Bool
      @catched = false
    end

    def pretty_signature(d : Def) : String
      restrictions = d.args.map &.restriction
      unless d.args.all? { |x| x.restriction }
        raise ArgumentError.new "No type restrictions on #{d.args.select { |x| !x.restriction }.join(",")} (method #{d.name})"
      end
      "#{d.name}(#{restrictions.map(&.to_s).join(",")})" + (d.return_type ? " : #{d.return_type.to_s}" : "")
    end

    def transpile(node, should_return : Bool = false)
      if @failsafe
        "#warning Node type #{node.class} isn't supported yet"
      else
        raise Error.new("Node type #{node.class} isn't supported yet")
      end
    end

    def transpile_type(_n : String)
      if _n.match(/\|/)
        raise Error.new("Union types are not supported yet (type #{_n})")
      elsif CORE_TYPES.includes?(_n)
        "crystal::#{_n.downcase}"
      elsif BUILTIN_TYPES.includes?(_n)
        _n.downcase
      else
        _n
      end
    end

    def transpile(node : TypeNode, should_return : Bool = false)
      (should_return ? "return " : "") + transpile_type(node.to_s)
    end

    def transpile(node : Path, should_return : Bool = false)
      node.names[0] = transpile_type node.names.first
      (should_return ? "return " : "") + (node.global? ? "::" : "") + "#{node.names.join("::")}"
    end

    def transpile(node : Generic, should_return : Bool = false)
      (should_return ? "return " : "") + "#{transpile node.name}< #{node.type_vars.map { |x| transpile x }.join(",")} >"
    end

    def transpile(node : Nop, should_return : Bool = false)
      ""
    end
  end
end
